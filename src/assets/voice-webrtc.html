<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice WebRTC - Enhanced</title>
    <!-- WebRTC adapter.js polyfill -->
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .timer {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }

        .participant-info {
            text-align: center;
            margin-bottom: 20px;
        }

        .audio-visualizer {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 100px;
            margin-bottom: 20px;
        }

        .audio-bar {
            width: 8px;
            margin: 0 2px;
            background: linear-gradient(to top, #4CAF50, #8BC34A);
            border-radius: 4px 4px 0 0;
            transition: height 0.1s ease;
        }

        .connection-status {
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .status-excellent { background-color: #4CAF50; color: white; }
        .status-good { background-color: #8BC34A; color: white; }
        .status-fair { background-color: #FF9800; color: white; }
        .status-poor { background-color: #F44336; color: white; }
        .status-connecting { background-color: #2196F3; color: white; }
        .status-reconnecting { background-color: #FF5722; color: white; }

        .audio-metrics {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .metric {
            text-align: center;
        }

        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #2196F3;
        }

        .metric-label {
            font-size: 12px;
            color: #666;
        }

        .controls {
            display: flex;
            justify-content: space-evenly;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
        }

        .control-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-button:hover {
            transform: scale(1.1);
        }

        .mute-button { background-color: #4CAF50; }
        .mute-button.muted { background-color: #F44336; }
        .end-button { background-color: #F44336; }

        .reconnection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .reconnection-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 300px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h2>Voice Consultation</h2>
            <div class="timer" id="timer">00:00</div>
        </div>

        <div class="connection-status" id="connectionStatus">
            Initializing connection...
        </div>

        <div class="audio-metrics" id="audioMetrics">
            <div class="metric">
                <div class="metric-value" id="audioLevel">-âˆž</div>
                <div class="metric-label">Level (dB)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="audioQuality">--</div>
                <div class="metric-label">Quality (%)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="noiseLevel">--</div>
                <div class="metric-label">Noise (%)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="connectionRTT">--</div>
                <div class="metric-label">Latency (ms)</div>
            </div>
        </div>

        <div class="participant-info" id="participantInfo">
            <p>Connecting to astrologer...</p>
        </div>

        <div class="audio-visualizer" id="audioVisualizer">
            <div class="audio-bar" style="height: 20px;"></div>
            <div class="audio-bar" style="height: 40px;"></div>
            <div class="audio-bar" style="height: 30px;"></div>
            <div class="audio-bar" style="height: 50px;"></div>
            <div class="audio-bar" style="height: 25px;"></div>
            <div class="audio-bar" style="height: 45px;"></div>
            <div class="audio-bar" style="height: 35px;"></div>
            <div class="audio-bar" style="height: 20px;"></div>
        </div>

        <div class="controls">
            <button class="control-button mute-button" id="toggleMic" title="Toggle Microphone">
                ðŸŽ¤
            </button>
            <button class="control-button end-button" id="endCall" title="End Call">
                ðŸ“ž
            </button>
        </div>
    </div>

    <div class="reconnection-overlay" id="reconnectionOverlay">
        <div class="reconnection-content">
            <h3>Connection Lost</h3>
            <div class="spinner"></div>
            <p id="reconnectionStatus">Attempting to reconnect...</p>
            <p id="reconnectionAttempt">Attempt 1 of 5</p>
        </div>
    </div>

    <script>
        // Enhanced WebRTC Configuration
        const WebRTCConfig = {
            getICEServers: () => {
                return [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    {
                        urls: [
                            'turn:relay1.expressturn.com:3478',
                            'turns:relay1.expressturn.com:5349'
                        ],
                        username: 'efJOINT4K6DPKWSB',
                        credential: 'Wjk8VVJaVmJUZGhOVEF4'
                    },
                    {
                        urls: [
                            'turn:openrelay.metered.ca:80',
                            'turn:openrelay.metered.ca:443',
                            'turns:openrelay.metered.ca:443'
                        ],
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ];
            },

            getPeerConnectionConfig: () => {
                return {
                    iceServers: WebRTCConfig.getICEServers(),
                    iceCandidatePoolSize: 20,
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                    iceTransportPolicy: 'all'
                };
            },

            getMediaConstraints: () => {
                return {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 48000,
                        channelCount: 1,
                        volume: 1.0,
                        googEchoCancellation: true,
                        googAutoGainControl: true,
                        googNoiseSuppression: true,
                        googHighpassFilter: true,
                        googTypingNoiseDetection: true,
                        googAudioMirroring: false
                    }
                };
            },

            qualityThresholds: {
                excellent: { rtt: 50, packetLoss: 0.01 },
                good: { rtt: 150, packetLoss: 0.03 },
                fair: { rtt: 300, packetLoss: 0.05 },
                poor: { rtt: 500, packetLoss: 0.1 }
            },

            reconnection: {
                maxAttempts: 5,
                initialDelay: 1000,
                maxDelay: 30000,
                backoffFactor: 2
            }
        };

        // Audio Processing Service
        class AudioProcessingService {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.gainNode = null;
                this.compressor = null;
                this.source = null;
                this.destination = null;
                this.isMonitoring = false;
                this.audioMetrics = {
                    averageLevel: 0,
                    peakLevel: 0,
                    noiseLevel: 0,
                    quality: 0
                };
            }

            async initializeAudioProcessing(inputStream) {
                try {
                    logWebRTC('INFO', 'Initializing advanced audio processing...');
                    
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.source = this.audioContext.createMediaStreamSource(inputStream);
                    
                    await this.createProcessingPipeline();
                    this.connectProcessingPipeline();
                    
                    this.destination = this.audioContext.createMediaStreamDestination();
                    this.compressor.connect(this.destination);
                    
                    logWebRTC('SUCCESS', 'Audio processing pipeline initialized');
                    return this.destination.stream;
                    
                } catch (error) {
                    logWebRTC('ERROR', 'Failed to initialize audio processing: ' + error.message);
                    return inputStream;
                }
            }

            async createProcessingPipeline() {
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;
                
                this.gainNode = this.audioContext.createGain();
                this.gainNode.gain.value = 1.0;
                
                this.compressor = this.audioContext.createDynamicsCompressor();
                this.compressor.threshold.value = -24;
                this.compressor.knee.value = 30;
                this.compressor.ratio.value = 12;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;
            }

            connectProcessingPipeline() {
                this.source.connect(this.analyser);
                this.analyser.connect(this.gainNode);
                this.gainNode.connect(this.compressor);
            }

            startAudioLevelMonitoring(callback) {
                this.isMonitoring = true;
                
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                const frequencyArray = new Uint8Array(bufferLength);
                
                const monitor = () => {
                    if (!this.isMonitoring) return;
                    
                    this.analyser.getByteTimeDomainData(dataArray);
                    this.analyser.getByteFrequencyData(frequencyArray);
                    
                    const metrics = this.calculateAudioMetrics(dataArray, frequencyArray);
                    this.audioMetrics = metrics;
                    
                    if (callback) callback(metrics);
                    
                    requestAnimationFrame(monitor);
                };
                
                monitor();
            }

            calculateAudioMetrics(timeData, frequencyData) {
                let sum = 0;
                let peak = 0;
                
                for (let i = 0; i < timeData.length; i++) {
                    const sample = (timeData[i] - 128) / 128.0;
                    sum += sample * sample;
                    peak = Math.max(peak, Math.abs(sample));
                }
                
                const rms = Math.sqrt(sum / timeData.length);
                const averageLevel = 20 * Math.log10(rms + 1e-10);
                const peakLevel = 20 * Math.log10(peak + 1e-10);
                
                let noiseLevelSum = 0;
                const noiseBins = Math.floor(frequencyData.length * 0.1);
                
                for (let i = 0; i < noiseBins; i++) {
                    noiseLevelSum += frequencyData[i];
                }
                
                const noiseLevel = (noiseLevelSum / noiseBins) / 255.0 * 100;
                
                let signalLevelSum = 0;
                const signalStart = Math.floor(frequencyData.length * 0.1);
                const signalEnd = Math.floor(frequencyData.length * 0.8);
                
                for (let i = signalStart; i < signalEnd; i++) {
                    signalLevelSum += frequencyData[i];
                }
                
                const signalLevel = (signalLevelSum / (signalEnd - signalStart)) / 255.0 * 100;
                const snr = signalLevel > 0 ? signalLevel / (noiseLevel + 1e-10) : 0;
                
                return {
                    averageLevel: Math.max(averageLevel, -60),
                    peakLevel: Math.max(peakLevel, -60),
                    noiseLevel: noiseLevel,
                    signalLevel: signalLevel,
                    snr: snr,
                    quality: this.calculateQualityScore(averageLevel, peakLevel, snr)
                };
            }

            calculateQualityScore(averageLevel, peakLevel, snr) {
                let score = 0;
                
                if (averageLevel >= -20 && averageLevel <= -6) {
                    score += 40;
                } else if (averageLevel >= -30 && averageLevel <= -3) {
                    score += 20;
                }
                
                const dynamicRange = peakLevel - averageLevel;
                if (dynamicRange >= 6 && dynamicRange <= 20) {
                    score += 30;
                } else if (dynamicRange >= 3 && dynamicRange <= 25) {
                    score += 15;
                }
                
                if (snr >= 10) {
                    score += 30;
                } else if (snr >= 5) {
                    score += 20;
                } else if (snr >= 2) {
                    score += 10;
                }
                
                return Math.min(score, 100);
            }

            cleanup() {
                this.isMonitoring = false;
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
            }
        }

        // Reconnection Service
        class ReconnectionService {
            constructor(onReconnectAttempt, onReconnectSuccess, onReconnectFailed) {
                this.onReconnectAttempt = onReconnectAttempt;
                this.onReconnectSuccess = onReconnectSuccess;
                this.onReconnectFailed = onReconnectFailed;
                
                this.reconnectAttempts = 0;
                this.maxAttempts = WebRTCConfig.reconnection.maxAttempts;
                this.currentDelay = WebRTCConfig.reconnection.initialDelay;
                this.isReconnecting = false;
                this.reconnectTimer = null;
                this.qualityCheckInterval = null;
                this.connectionQuality = 'unknown';
            }

            startReconnection(sessionData) {
                if (this.isReconnecting) return;

                this.isReconnecting = true;
                this.reconnectAttempts = 0;
                this.currentDelay = WebRTCConfig.reconnection.initialDelay;

                logWebRTC('INFO', 'Starting reconnection process...');
                this.showReconnectionOverlay();
                this.attemptReconnection(sessionData);
            }

            async attemptReconnection(sessionData) {
                if (this.reconnectAttempts >= this.maxAttempts) {
                    logWebRTC('ERROR', 'Max reconnection attempts reached');
                    this.isReconnecting = false;
                    this.hideReconnectionOverlay();
                    this.onReconnectFailed('Max attempts reached');
                    return;
                }

                this.reconnectAttempts++;
                logWebRTC('INFO', `Reconnection attempt ${this.reconnectAttempts}/${this.maxAttempts}`);
                
                this.updateReconnectionUI(this.reconnectAttempts, this.currentDelay);
                
                if (this.onReconnectAttempt) {
                    this.onReconnectAttempt(this.reconnectAttempts, this.currentDelay);
                }

                this.reconnectTimer = setTimeout(async () => {
                    try {
                        await this.createNewConnection(sessionData);
                        
                        logWebRTC('SUCCESS', 'Successfully reconnected');
                        this.isReconnecting = false;
                        this.hideReconnectionOverlay();
                        
                        if (this.onReconnectSuccess) {
                            this.onReconnectSuccess();
                        }
                        
                    } catch (error) {
                        logWebRTC('ERROR', 'Reconnection attempt failed: ' + error.message);
                        
                        this.currentDelay = Math.min(
                            this.currentDelay * WebRTCConfig.reconnection.backoffFactor,
                            WebRTCConfig.reconnection.maxDelay
                        );
                        
                        this.attemptReconnection(sessionData);
                    }
                }, this.currentDelay);
            }

            async createNewConnection(sessionData) {
                // Close existing connection
                if (peerConnection) {
                    peerConnection.close();
                }

                // Reinitialize WebRTC
                await initWebRTC();
                
                // Reinitialize with session data
                if (window.initData) {
                    await reinitializeWebRTC(window.initData);
                }
            }

            showReconnectionOverlay() {
                document.getElementById('reconnectionOverlay').style.display = 'flex';
            }

            hideReconnectionOverlay() {
                document.getElementById('reconnectionOverlay').style.display = 'none';
            }

            updateReconnectionUI(attempt, delay) {
                document.getElementById('reconnectionAttempt').textContent = `Attempt ${attempt} of ${this.maxAttempts}`;
                document.getElementById('reconnectionStatus').textContent = `Reconnecting in ${Math.round(delay/1000)} seconds...`;
            }

            stopReconnection() {
                this.isReconnecting = false;
                
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                    this.reconnectTimer = null;
                }
                
                this.hideReconnectionOverlay();
            }
        }

        // Communication with React Native
        function sendToReactNative(message) {
            try {
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage(JSON.stringify(message));
                }
                console.log('Sent to React Native:', message);
            } catch (error) {
                console.error('Error sending to React Native:', error);
            }
        }
        
        // Function to notify that WebRTC connection is established
        function notifyWebRTCConnectionEstablished() {
            logWebRTC('SUCCESS', 'WebRTC connection fully established with audio');
            sendToReactNative({
                type: 'webrtc_local_connection_established',
                data: { established: true }
            });
            
            // Optionally start the timer if needed
            // explicitStartTimer();
        }
        
        // Report connection state to React Native
        function reportConnectionState(state) {
            sendToReactNative({
                type: 'webrtc_connection_state',
                data: { state: state }
            });
        }
        
        // Report ICE state to React Native
        function reportIceState(state) {
            sendToReactNative({
                type: 'webrtc_ice_state',
                data: { state: state }
            });
        }

        // Debug logger
        function logWebRTC(type, message) {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const logElement = document.getElementById('log');
            const logLine = `[${timestamp}] [${type}] ${message}`;
            console.log(logLine);
            
            if (logElement) {
                logElement.innerHTML += `<div class="log-${type.toLowerCase()}">${logLine}</div>`;
            }
            
            // Send logs to React Native for debugging
            sendToReactNative({
                type: 'webrtc_log',
                data: { level: type, message: logLine }
            });
        }

        // Variables
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let isMuted = false;
        let timer;
        let seconds = 0;
        let timerStarted = false;
        let participantName = "Astrologer";
        let participantType = "astrologer";
        let hasNotifiedConnectionEstablished = false;
        let isWebRTCReady = false;
        let reconnectionService = null;
        let audioProcessingService = null;
        
        // Initialize WebRTC
        async function initWebRTC() {
            try {
                logWebRTC('INFO', 'Initializing WebRTC...');
                updateConnectionStatus('Initializing connection...', 'connecting');

                // Check for required APIs
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('WebRTC is not supported in this browser');
                }

                // Get user media with enhanced constraints
                const constraints = WebRTCConfig.getMediaConstraints();
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                logWebRTC('SUCCESS', 'Got user media stream');

                // Initialize audio processing
                audioProcessingService = new AudioProcessingService();
                const processedStream = await audioProcessingService.initializeAudioProcessing(localStream);
                
                // Use processed stream if available, fallback to original
                const streamToUse = processedStream || localStream;

                // Create RTCPeerConnection
                const config = WebRTCConfig.getPeerConnectionConfig();
                peerConnection = new RTCPeerConnection(config);
                logWebRTC('INFO', 'Created RTCPeerConnection');

                // Initialize reconnection service
                reconnectionService = new ReconnectionService(
                    (attempt, delay) => {
                        logWebRTC('INFO', `Reconnection attempt ${attempt}, delay: ${delay}ms`);
                    },
                    () => {
                        logWebRTC('SUCCESS', 'Reconnection successful');
                        updateConnectionStatus('Reconnected successfully', 'excellent');
                    },
                    (reason) => {
                        logWebRTC('ERROR', `Reconnection failed: ${reason}`);
                        updateConnectionStatus('Connection failed - please refresh', 'poor');
                    }
                );

                // Add local stream tracks to peer connection
                streamToUse.getTracks().forEach(track => {
                    peerConnection.addTrack(track, streamToUse);
                    logWebRTC('INFO', `Added ${track.kind} track to peer connection`);
                });

                // Set up peer connection event handlers
                setupPeerConnectionHandlers();

                // Start audio level monitoring
                if (audioProcessingService) {
                    audioProcessingService.startAudioLevelMonitoring((metrics) => {
                        updateAudioMetrics(metrics);
                        updateAudioVisualizer(metrics.averageLevel);
                    });
                }

                // Start connection quality monitoring
                startConnectionQualityMonitoring();

                isWebRTCReady = true;
                logWebRTC('SUCCESS', 'WebRTC initialization completed');
                updateConnectionStatus('Ready to connect', 'good');

            } catch (error) {
                logWebRTC('ERROR', 'Failed to initialize WebRTC: ' + error.message);
                updateConnectionStatus('Initialization failed: ' + error.message, 'poor');
                throw error;
            }
        }

        // Setup peer connection event handlers
        function setupPeerConnectionHandlers() {
            // ICE candidate event
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    logWebRTC('INFO', 'Generated ICE candidate');
                    sendSignalingMessage({
                        type: 'ice-candidate',
                        candidate: event.candidate,
                        sessionId: sessionId
                    });
                } else {
                    logWebRTC('INFO', 'ICE candidate gathering completed');
                }
            };

            // Remote stream event
            peerConnection.ontrack = (event) => {
                logWebRTC('INFO', 'Received remote track');
                const [remoteStream] = event.streams;
                
                // Create audio element for remote stream
                const remoteAudio = document.createElement('audio');
                remoteAudio.srcObject = remoteStream;
                remoteAudio.autoplay = true;
                remoteAudio.playsInline = true;
                document.body.appendChild(remoteAudio);
                
                updateParticipantInfo('Connected to astrologer');
                updateConnectionStatus('Voice call active', 'excellent');
                
                if (!hasNotifiedConnectionEstablished) {
                    sendToReactNative({
                        type: 'connection_established',
                        sessionId: sessionId
                    });
                    hasNotifiedConnectionEstablished = true;
                }
            };

            // Connection state change
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                logWebRTC('INFO', `Connection state changed to: ${state}`);
                
                switch (state) {
                    case 'connecting':
                        updateConnectionStatus('Connecting to astrologer...', 'connecting');
                        break;
                    case 'connected':
                        updateConnectionStatus('Voice call active', 'excellent');
                        break;
                    case 'disconnected':
                        updateConnectionStatus('Connection lost', 'poor');
                        if (reconnectionService && window.initData) {
                            reconnectionService.startReconnection(window.initData);
                        }
                        break;
                    case 'failed':
                        updateConnectionStatus('Connection failed', 'poor');
                        if (reconnectionService && window.initData) {
                            reconnectionService.startReconnection(window.initData);
                        }
                        break;
                    case 'closed':
                        updateConnectionStatus('Call ended', 'poor');
                        break;
                }
            };

            // ICE connection state change
            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                logWebRTC('INFO', `ICE connection state changed to: ${state}`);
                
                switch (state) {
                    case 'checking':
                        updateConnectionStatus('Establishing connection...', 'connecting');
                        break;
                    case 'connected':
                    case 'completed':
                        updateConnectionStatus('Voice call active', 'excellent');
                        break;
                    case 'disconnected':
                        updateConnectionStatus('Connection unstable', 'fair');
                        break;
                    case 'failed':
                        updateConnectionStatus('Connection failed', 'poor');
                        if (reconnectionService && window.initData) {
                            reconnectionService.startReconnection(window.initData);
                        }
                        break;
                    case 'closed':
                        updateConnectionStatus('Call ended', 'poor');
                        break;
                }
            };
        }

        // Start connection quality monitoring
        function startConnectionQualityMonitoring() {
            setInterval(async () => {
                if (peerConnection && peerConnection.connectionState === 'connected') {
                    try {
                        const stats = await peerConnection.getStats();
                        const quality = analyzeConnectionQuality(stats);
                        updateConnectionQuality(quality);
                    } catch (error) {
                        logWebRTC('ERROR', 'Failed to get connection stats: ' + error.message);
                    }
                }
            }, 2000); // Check every 2 seconds
        }

        // Analyze connection quality from WebRTC stats
        function analyzeConnectionQuality(stats) {
            let rtt = 0;
            let packetLoss = 0;
            let jitter = 0;
            let bytesReceived = 0;
            let bytesSent = 0;

            stats.forEach(report => {
                if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                    rtt = report.currentRoundTripTime * 1000; // Convert to ms
                }
                
                if (report.type === 'inbound-rtp' && report.mediaType === 'audio') {
                    packetLoss = report.packetsLost / (report.packetsReceived + report.packetsLost);
                    jitter = report.jitter;
                    bytesReceived = report.bytesReceived;
                }
                
                if (report.type === 'outbound-rtp' && report.mediaType === 'audio') {
                    bytesSent = report.bytesSent;
                }
            });

            // Determine quality level
            const thresholds = WebRTCConfig.qualityThresholds;
            let quality = 'poor';
            
            if (rtt <= thresholds.excellent.rtt && packetLoss <= thresholds.excellent.packetLoss) {
                quality = 'excellent';
            } else if (rtt <= thresholds.good.rtt && packetLoss <= thresholds.good.packetLoss) {
                quality = 'good';
            } else if (rtt <= thresholds.fair.rtt && packetLoss <= thresholds.fair.packetLoss) {
                quality = 'fair';
            }

            return {
                quality,
                rtt: Math.round(rtt),
                packetLoss: Math.round(packetLoss * 100),
                jitter: Math.round(jitter * 1000),
                bytesReceived,
                bytesSent
            };
        }

        // Update connection quality UI
        function updateConnectionQuality(qualityData) {
            document.getElementById('connectionRTT').textContent = qualityData.rtt + 'ms';
            
            // Update connection status based on quality
            const qualityMessages = {
                excellent: 'Excellent connection quality',
                good: 'Good connection quality',
                fair: 'Fair connection quality',
                poor: 'Poor connection quality'
            };
            
            if (peerConnection.connectionState === 'connected') {
                updateConnectionStatus(qualityMessages[qualityData.quality], qualityData.quality);
            }
        }

        // Update audio metrics UI
        function updateAudioMetrics(metrics) {
            document.getElementById('audioLevel').textContent = Math.round(metrics.averageLevel) + 'dB';
            document.getElementById('audioQuality').textContent = Math.round(metrics.quality) + '%';
            document.getElementById('noiseLevel').textContent = Math.round(metrics.noiseLevel) + '%';
        }

        // Update audio visualizer
        function updateAudioVisualizer(audioLevel) {
            const bars = document.querySelectorAll('.audio-bar');
            const normalizedLevel = Math.max(0, (audioLevel + 60) / 60); // Normalize -60dB to 0dB to 0-1
            
            bars.forEach((bar, index) => {
                const barHeight = Math.max(5, normalizedLevel * 80 * (0.5 + Math.random() * 0.5));
                bar.style.height = barHeight + 'px';
                
                // Add color based on level
                if (normalizedLevel > 0.7) {
                    bar.style.background = 'linear-gradient(to top, #4CAF50, #8BC34A)';
                } else if (normalizedLevel > 0.3) {
                    bar.style.background = 'linear-gradient(to top, #FF9800, #FFC107)';
                } else {
                    bar.style.background = 'linear-gradient(to top, #F44336, #FF5722)';
                }
            });
        }

        // Update connection status
        function updateConnectionStatus(message, status) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.textContent = message;
            statusElement.className = 'connection-status status-' + status;
        }

        // Update participant info
        function updateParticipantInfo(message) {
            document.getElementById('participantInfo').innerHTML = '<p>' + message + '</p>';
        }

        // Reinitialize WebRTC (for reconnection)
        async function reinitializeWebRTC(initData) {
            try {
                logWebRTC('INFO', 'Reinitializing WebRTC for reconnection...');
                
                // Store the init data
                window.initData = initData;
                
                // Reset state
                hasNotifiedConnectionEstablished = false;
                
                // Initialize WebRTC
                await initWebRTC();
                
                // Handle the initialization based on participant type
                if (initData.type === 'offer') {
                    await handleOffer(initData.offer, initData.sessionId);
                } else if (initData.type === 'answer') {
                    await handleAnswer(initData.answer);
                } else if (initData.type === 'start_call') {
                    await startCall(initData.sessionId, initData.participantType);
                }
                
                logWebRTC('SUCCESS', 'WebRTC reinitialized successfully');
                
            } catch (error) {
                logWebRTC('ERROR', 'Failed to reinitialize WebRTC: ' + error.message);
                throw error;
            }
        }

        // Handle offer
        async function handleOffer(offer, sessionIdParam) {
            try {
                logWebRTC('INFO', 'Handling offer...');
                sessionId = sessionIdParam;
                
                if (!isWebRTCReady) {
                    await initWebRTC();
                }

                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                logWebRTC('INFO', 'Set remote description (offer)');

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                logWebRTC('INFO', 'Created and set local description (answer)');

                sendSignalingMessage({
                    type: 'answer',
                    answer: answer,
                    sessionId: sessionId
                });

                updateConnectionStatus('Connecting...', 'connecting');
                
            } catch (error) {
                logWebRTC('ERROR', 'Failed to handle offer: ' + error.message);
                updateConnectionStatus('Failed to connect: ' + error.message, 'poor');
                throw error;
            }
        }

        // Handle answer
        async function handleAnswer(answer) {
            try {
                logWebRTC('INFO', 'Handling answer...');
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                logWebRTC('SUCCESS', 'Set remote description (answer)');
                
            } catch (error) {
                logWebRTC('ERROR', 'Failed to handle answer: ' + error.message);
                throw error;
            }
        }

        // Handle ICE candidate
        async function handleIceCandidate(candidate) {
            try {
                logWebRTC('INFO', 'Adding ICE candidate...');
                
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                logWebRTC('SUCCESS', 'Added ICE candidate');
                
            } catch (error) {
                logWebRTC('ERROR', 'Failed to add ICE candidate: ' + error.message);
            }
        }

        // Start call (create offer)
        async function startCall(sessionIdParam, participantTypeParam) {
            try {
                logWebRTC('INFO', 'Starting call...');
                sessionId = sessionIdParam;
                participantType = participantTypeParam;
                
                if (!isWebRTCReady) {
                    await initWebRTC();
                }

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                logWebRTC('INFO', 'Created and set local description (offer)');

                sendSignalingMessage({
                    type: 'offer',
                    offer: offer,
                    sessionId: sessionId
                });

                updateConnectionStatus('Calling astrologer...', 'connecting');
                
            } catch (error) {
                logWebRTC('ERROR', 'Failed to start call: ' + error.message);
                updateConnectionStatus('Failed to start call: ' + error.message, 'poor');
                throw error;
            }
        }

        // End call
        function endCall() {
            try {
                logWebRTC('INFO', 'Ending call...');
                
                // Stop reconnection if active
                if (reconnectionService) {
                    reconnectionService.stopReconnection();
                }
                
                // Cleanup audio processing
                if (audioProcessingService) {
                    audioProcessingService.cleanup();
                }
                
                // Close peer connection
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                
                // Stop local stream
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                
                // Remove remote audio elements
                const remoteAudios = document.querySelectorAll('audio');
                remoteAudios.forEach(audio => audio.remove());
                
                updateConnectionStatus('Call ended', 'poor');
                
                // Notify React Native
                sendToReactNative({
                    type: 'call_ended',
                    sessionId: sessionId
                });
                
                logWebRTC('SUCCESS', 'Call ended successfully');
                
            } catch (error) {
                logWebRTC('ERROR', 'Error ending call: ' + error.message);
            }
        }

        // Toggle microphone
        function toggleMicrophone() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    const button = document.getElementById('toggleMic');
                    
                    if (audioTrack.enabled) {
                        button.textContent = 'ðŸŽ¤';
                        button.classList.remove('muted');
                        logWebRTC('INFO', 'Microphone unmuted');
                    } else {
                        button.textContent = 'ðŸ”‡';
                        button.classList.add('muted');
                        logWebRTC('INFO', 'Microphone muted');
                    }
                    
                    sendToReactNative({
                        type: 'mic_toggled',
                        muted: !audioTrack.enabled,
                        sessionId: sessionId
                    });
                }
            }
        }

        // Timer functionality
        let timerInterval;
        let startTime;

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Event listeners
        document.getElementById('toggleMic').addEventListener('click', toggleMicrophone);
        document.getElementById('endCall').addEventListener('click', endCall);

        // Message handler from React Native
        window.addEventListener('message', (event) => {
            try {
                const data = JSON.parse(event.data);
                logWebRTC('INFO', 'Received message from React Native: ' + data.type);
                
                // Store init data for reconnection
                window.initData = data;
                
                switch (data.type) {
                    case 'offer':
                        handleOffer(data.offer, data.sessionId);
                        startTimer();
                        break;
                    case 'answer':
                        handleAnswer(data.answer);
                        startTimer();
                        break;
                    case 'ice-candidate':
                        handleIceCandidate(data.candidate);
                        break;
                    case 'start_call':
                        startCall(data.sessionId, data.participantType);
                        startTimer();
                        break;
                    case 'end_call':
                        endCall();
                        stopTimer();
                        break;
                    default:
                        logWebRTC('WARNING', 'Unknown message type: ' + data.type);
                }
            } catch (error) {
                logWebRTC('ERROR', 'Failed to handle message: ' + error.message);
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            logWebRTC('INFO', 'Voice WebRTC page loaded');
            updateConnectionStatus('Ready to initialize', 'connecting');
        });

        // Handle page visibility change (for mobile app backgrounding)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                logWebRTC('INFO', 'Page hidden - maintaining connection');
            } else {
                logWebRTC('INFO', 'Page visible - checking connection');
                if (peerConnection && peerConnection.connectionState === 'disconnected') {
                    if (reconnectionService && window.initData) {
                        reconnectionService.startReconnection(window.initData);
                    }
                }
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            endCall();
        });

        logWebRTC('SUCCESS', 'Enhanced Voice WebRTC initialized with production-ready features');
    </script>
</body>
</html>
