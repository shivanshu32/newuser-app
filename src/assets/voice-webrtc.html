<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice WebRTC</title>
    <!-- WebRTC adapter.js polyfill -->
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .timer {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }

        .participant-info {
            text-align: center;
            margin-bottom: 20px;
        }

        .audio-visualizer {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 100px;
            margin-bottom: 20px;
            background-color: #eee;
            border-radius: 10px;
            padding: 10px;
        }

        .audio-bar {
            width: 5px;
            height: 20px;
            background-color: #667eea;
            margin: 0 2px;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-top: auto;
            padding: 20px 0;
        }

        .control-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            margin: 0 10px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #toggleMic {
            background-color: #4CAF50;
        }

        #toggleMic.muted {
            background-color: #f44336;
        }

        #endCall {
            background-color: #f44336;
        }

        .icon {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .status {
            text-align: center;
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h2>Voice Consultation</h2>
        </div>

        <div class="timer" id="timer">00:00</div>

        <div class="participant-info" id="participantInfo">
            Connecting to participant...
        </div>

        <div class="audio-visualizer" id="audioVisualizer">
            <!-- Audio bars will be added dynamically -->
        </div>

        <div class="status" id="connectionStatus">Initializing WebRTC...</div>

        <div class="controls">
            <button class="control-button" id="toggleMic">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z" />
                </svg>
            </button>
            <button class="control-button" id="endCall">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M12,9C10.4,9 8.85,9.25 7.4,9.72V12.82C7.4,13.22 7.17,13.56 6.84,13.72C5.86,14.21 4.97,14.84 4.17,15.57C4,15.75 3.75,15.86 3.5,15.86C3.2,15.86 2.95,15.74 2.77,15.56L0.29,13.08C0.11,12.9 0,12.65 0,12.38C0,12.1 0.11,11.85 0.29,11.67C3.34,8.77 7.46,7 12,7C16.54,7 20.66,8.77 23.71,11.67C23.89,11.85 24,12.1 24,12.38C24,12.65 23.89,12.9 23.71,13.08L21.23,15.56C21.05,15.74 20.8,15.86 20.5,15.86C20.25,15.86 20,15.75 19.82,15.57C19.03,14.84 18.14,14.21 17.16,13.72C16.83,13.56 16.6,13.22 16.6,12.82V9.72C15.15,9.25 13.6,9 12,9Z" />
                </svg>
            </button>
        </div>
    </div>

    <script>
        // Communication with React Native
        function sendToReactNative(message) {
            try {
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage(JSON.stringify(message));
                }
                console.log('Sent to React Native:', message);
            } catch (error) {
                console.error('Error sending to React Native:', error);
            }
        }
        
        // Function to notify that WebRTC connection is established
        function notifyWebRTCConnectionEstablished() {
            logWebRTC('SUCCESS', 'WebRTC connection fully established with audio');
            sendToReactNative({
                type: 'webrtc_local_connection_established',
                data: { established: true }
            });
            
            // Optionally start the timer if needed
            // explicitStartTimer();
        }
        
        // Report connection state to React Native
        function reportConnectionState(state) {
            sendToReactNative({
                type: 'webrtc_connection_state',
                data: { state: state }
            });
        }
        
        // Report ICE state to React Native
        function reportIceState(state) {
            sendToReactNative({
                type: 'webrtc_ice_state',
                data: { state: state }
            });
        }

        // Debug logger
        function logWebRTC(type, message) {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const logElement = document.getElementById('log');
            const logLine = `[${timestamp}] [${type}] ${message}`;
            console.log(logLine);
            
            if (logElement) {
                logElement.innerHTML += `<div class="log-${type.toLowerCase()}">${logLine}</div>`;
            }
            
            // Send logs to React Native for debugging
            sendToReactNative({
                type: 'webrtc_log',
                data: { level: type, message: logLine }
            });
        }

        // Variables
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let isMuted = false;
        let timer;
        let seconds = 0;
        let timerStarted = false;
        let participantName = "Astrologer";
        let participantType = "astrologer";
        let hasNotifiedConnectionEstablished = false;
        let isWebRTCReady = false;
        
        // Initialize WebRTC
        async function initWebRTC() {
            try {
                logWebRTC('INFO', 'Starting WebRTC initialization...');
                
                // Request audio stream from React Native instead of using getUserMedia
                logWebRTC('INFO', 'Requesting audio stream from React Native...');
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'request_audio_stream'
                }));
                
                // Wait for audio stream to be ready
                const audioReady = await waitForAudioStreamReady();
                if (!audioReady) {
                    throw new Error('Audio stream not ready from React Native');
                }
                
                // Create placeholder audio stream for WebRTC
                localStream = createPlaceholderAudioStream();
                logWebRTC('INFO', 'Created placeholder audio stream for WebRTC');
                
                let audioTracks = localStream.getAudioTracks();
                if (audioTracks.length > 0) {
                    logWebRTC('INFO', `Audio track: ${audioTracks[0].id}, label: ${audioTracks[0].label}, enabled: ${audioTracks[0].enabled}`);
                }

                // Create RTCPeerConnection
                const config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };

                peerConnection = new RTCPeerConnection(config);
                logWebRTC('INFO', 'Created RTCPeerConnection');

                // Add local stream to peer connection
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        logWebRTC('INFO', `Adding track to peer connection: ${track.kind} - ${track.label}`);
                        peerConnection.addTrack(track, localStream);
                    });
                }

                // Handle remote stream
                peerConnection.ontrack = (event) => {
                    logWebRTC('INFO', 'Received remote track');
                    const [remoteStream] = event.streams;
                    const remoteAudio = document.getElementById('remoteAudio');
                    if (remoteAudio) {
                        remoteAudio.srcObject = remoteStream;
                        logWebRTC('INFO', 'Set remote audio stream');
                    }
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        logWebRTC('INFO', 'Generated ICE candidate');
                        sendToReactNative({
                            type: 'ice_candidate',
                            data: {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid
                            }
                        });
                    } else {
                        logWebRTC('INFO', 'ICE candidate gathering complete');
                    }
                };

                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    const state = peerConnection.connectionState;
                    logWebRTC('INFO', `Connection state changed: ${state}`);
                    sendToReactNative({
                        type: 'connection_state_change',
                        data: { state }
                    });
                };

                // Handle ICE connection state changes
                peerConnection.oniceconnectionstatechange = () => {
                    const state = peerConnection.iceConnectionState;
                    logWebRTC('INFO', `ICE connection state changed: ${state}`);
                    sendToReactNative({
                        type: 'ice_connection_state_change',
                        data: { state }
                    });
                };

                // Process any pending ICE candidates
                processPendingCandidates();

                logWebRTC('SUCCESS', 'WebRTC initialization completed successfully');
                sendToReactNative({ type: 'webrtc_ready', data: { ready: true } });
                isWebRTCReady = true;

            } catch (error) {
                logWebRTC('ERROR', `Failed to initialize WebRTC: ${error.message}`);
                sendToReactNative({ 
                    type: 'webrtc_error', 
                    data: { error: error.message } 
                });
            }
        }
        
        // Set up peer connection event handlers
        function setupPeerConnectionEventHandlers() {
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    logWebRTC('INFO', `Generated ICE candidate: ${event.candidate.candidate.substr(0, 50)}...`);
                    sendToReactNative({
                        type: 'voice_ice_candidate',
                        data: { candidate: event.candidate }
                    });
                } else {
                    logWebRTC('INFO', 'ICE candidate generation complete (null candidate received)');
                }
            };
            
            // Handle ICE connection state changes
            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                logWebRTC('INFO', `ICE connection state changed to: ${state}`);
                
                // Report ICE state to React Native
                sendToReactNative({
                    type: 'webrtc_ice_state',
                    data: { state: state }
                });
                
                switch (state) {
                    case 'new':
                        logWebRTC('INFO', 'ICE connection created, gathering candidates...');
                        break;
                    case 'checking':
                        logWebRTC('INFO', 'ICE connection checking candidates...');
                        break;
                    case 'connected':
                    case 'completed':
                        logWebRTC('SUCCESS', `ICE connection ${state}`);
                        // Start the timer if we have a remote track
                        if (hasRemoteTrack) {
                            notifyWebRTCConnectionEstablished();
                        }
                        break;
                    case 'failed':
                        logWebRTC('ERROR', 'ICE connection failed');
                        // Try to restart ICE
                        try {
                            logWebRTC('INFO', 'Attempting to restart ICE...');
                            peerConnection.restartIce();
                        } catch (error) {
                            logWebRTC('ERROR', `Failed to restart ICE: ${error.message}`);
                        }
                        
                        // Report error to React Native
                        sendToReactNative({
                            type: 'webrtc_error',
                            data: { error: 'ICE connection failed. This could be due to firewall or network issues.' }
                        });
                        break;
                    case 'disconnected':
                        logWebRTC('WARNING', 'ICE connection disconnected');
                        break;
                    case 'closed':
                        logWebRTC('INFO', 'ICE connection closed');
                        break;
                }
            };
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                logWebRTC('INFO', `Connection state changed to: ${state}`);
                
                // Report connection state to React Native
                sendToReactNative({
                    type: 'webrtc_connection_state',
                    data: { state: state }
                });
                
                switch (state) {
                    case 'new':
                        logWebRTC('INFO', 'WebRTC connection created, not connected yet');
                        break;
                    case 'connecting':
                        logWebRTC('INFO', 'WebRTC connection establishing...');
                        break;
                    case 'connected':
                        logWebRTC('SUCCESS', 'WebRTC connection established successfully');
                        notifyWebRTCConnectionEstablished();
                        break;
                    case 'disconnected':
                        logWebRTC('WARNING', 'WebRTC connection temporarily disconnected');
                        break;
                    case 'failed':
                        logWebRTC('ERROR', 'WebRTC connection failed');
                        // Report error to React Native
                        sendToReactNative({
                            type: 'webrtc_error',
                            data: { error: 'WebRTC connection failed. Please check your network connection.' }
                        });
                        break;
                    case 'closed':
                        logWebRTC('INFO', 'WebRTC connection closed');
                        break;
                }
            };
            
            // Set up remote track handler
            peerConnection.ontrack = handleRemoteTrack;
            
            // Initial state reporting
            reportConnectionState(peerConnection.connectionState || 'new');
            reportIceState(peerConnection.iceConnectionState || 'new');
            
            // Notify React Native that WebRTC is ready
            sendToReactNative({
                type: 'webrtc_ready',
                data: { ready: true }
            });
        }

        // Handle remote audio tracks
        let hasRemoteTrack = false;
        function handleRemoteTrack(event) {
            logWebRTC('INFO', 'Received remote track event. Detailed event info:');
            
            // Log the entire event structure
            try {
                logWebRTC('DEBUG', `Track event has track: ${!!event.track}, streams: ${!!event.streams}, receiver: ${!!event.receiver}`);
                
                // Log track details if available
                if (event.track) {
                    logWebRTC('DEBUG', `Track details - id: ${event.track.id}, kind: ${event.track.kind}, enabled: ${event.track.enabled}, readyState: ${event.track.readyState}`);
                    
                    // Listen for track ended event
                    event.track.onended = () => {
                        logWebRTC('WARNING', `Remote track ${event.track.id} ended`);
                    };
                    
                    // Listen for track mute event
                    event.track.onmute = () => {
                        logWebRTC('WARNING', `Remote track ${event.track.id} muted`);
                    };
                    
                    // Listen for track unmute event
                    event.track.onunmute = () => {
                        logWebRTC('INFO', `Remote track ${event.track.id} unmuted`);
                    };
                }
                
                // Log receiver details if available
                if (event.receiver) {
                    logWebRTC('DEBUG', `Receiver track id: ${event.receiver.track?.id}`);
                }
            } catch (err) {
                logWebRTC('ERROR', `Error inspecting track event: ${err.message}`);
            }
            
            // Process the stream if available
            if (event.streams && event.streams.length > 0) {
                logWebRTC('SUCCESS', `Got remote stream with ${event.streams[0].getTracks().length} track(s)`);
                hasRemoteTrack = true;
                
                // Check if we already have an audio element
                let audioElement = document.getElementById('remoteAudio');
                if (!audioElement) {
                    // Create audio element to play the remote stream
                    audioElement = document.createElement('audio');
                    audioElement.id = 'remoteAudio';
                    audioElement.autoplay = true;
                    audioElement.playsInline = true;
                    audioElement.controls = true; // Add controls for debugging
                    audioElement.style.display = 'none'; // Hide the audio element
                    document.body.appendChild(audioElement);
                    
                    // Add event listeners to the audio element
                    audioElement.onplay = () => logWebRTC('INFO', 'Remote audio started playing');
                    audioElement.onpause = () => logWebRTC('INFO', 'Remote audio paused');
                    audioElement.onended = () => logWebRTC('INFO', 'Remote audio ended');
                    audioElement.onerror = (e) => logWebRTC('ERROR', `Remote audio error: ${e.target.error?.message || 'Unknown error'}`);
                }
                
                // Set the remote stream as the source for the audio element
                try {
                    audioElement.srcObject = event.streams[0];
                    logWebRTC('INFO', 'Set remote stream as audio source');
                    
                    // Force play the audio
                    audioElement.play()
                        .then(() => logWebRTC('SUCCESS', 'Remote audio playback started successfully'))
                        .catch(err => logWebRTC('ERROR', `Failed to play remote audio: ${err.message}`));
                } catch (err) {
                    logWebRTC('ERROR', `Error setting srcObject: ${err.message}`);
                }
                
                // Log the tracks in the remote stream
                const remoteTracks = event.streams[0].getTracks();
                logWebRTC('INFO', `Remote stream has ${remoteTracks.length} tracks`);
                remoteTracks.forEach((track, index) => {
                    logWebRTC('INFO', `Remote track ${index}: id=${track.id}, kind=${track.kind}, enabled=${track.enabled}, readyState=${track.readyState}`);
                    
                    // Check if the track has audio levels
                    try {
                        const settings = track.getSettings();
                        logWebRTC('DEBUG', `Track settings: ${JSON.stringify(settings)}`);
                    } catch (err) {
                        logWebRTC('WARNING', `Could not get track settings: ${err.message}`);
                    }
                });
                
                // Notify React Native about the remote track
                sendToReactNative({
                    type: 'remote_track_received',
                    data: {
                        trackCount: remoteTracks.length,
                        hasAudio: remoteTracks.some(t => t.kind === 'audio'),
                        streamId: event.streams[0].id
                    }
                });
                
                // If ICE connection is already established, notify connection
                if (peerConnection && 
                    (peerConnection.iceConnectionState === 'connected' || 
                     peerConnection.iceConnectionState === 'completed')) {
                    notifyWebRTCConnectionEstablished();
                }
            } else {
                logWebRTC('WARNING', 'Received track event without stream');
                
                // If we have a track but no stream, try to create a MediaStream
                if (event.track) {
                    try {
                        logWebRTC('INFO', 'Attempting to create MediaStream from track');
                        const stream = new MediaStream([event.track]);
                        
                        // Create audio element to play this stream
                        const audioElement = document.createElement('audio');
                        audioElement.id = 'remoteAudioFallback';
                        audioElement.autoplay = true;
                        audioElement.playsInline = true;
                        audioElement.controls = true; // Add controls for debugging
                        audioElement.style.display = 'none';
                        document.body.appendChild(audioElement);
                        
                        // Set the stream as source
                        audioElement.srcObject = stream;
                        audioElement.play()
                            .then(() => logWebRTC('SUCCESS', 'Fallback remote audio playback started'))
                            .catch(err => logWebRTC('ERROR', `Failed to play fallback remote audio: ${err.message}`));
                            
                        hasRemoteTrack = true;
                    } catch (err) {
                        logWebRTC('ERROR', `Failed to create fallback stream: ${err.message}`);
                    }
                }
            }
        }
        
        // Handle messages from React Native
        function handleMessage(event) {
            try {
                const message = JSON.parse(event.data);
                logWebRTC('INFO', `Received message from React Native: ${message.type}`);
                
                switch (message.type) {
                    case 'create_voice_offer':
                        logWebRTC('INFO', 'Creating voice offer...');
                        createOffer();
                        break;
                    
                    case 'voice_call_answer':
                        logWebRTC('INFO', 'Processing voice call answer...');
                        handleAnswer(message.data);
                        break;
                    
                    case 'voice_ice_candidate':
                        logWebRTC('INFO', 'Processing ICE candidate...');
                        handleIceCandidate(message.data);
                        break;
                    
                    case 'participant_info':
                        if (message.data) {
                            participantName = message.data.participantName || participantName;
                            participantType = message.data.participantType || participantType;
                            logWebRTC('INFO', `Updated participant info: ${participantName} (${participantType})`);
                        }
                        break;
                    
                    case 'restart_ice':
                        logWebRTC('INFO', 'Restarting ICE connection...');
                        if (peerConnection) {
                            try {
                                peerConnection.restartIce();
                                logWebRTC('SUCCESS', 'ICE restart initiated');
                            } catch (error) {
                                logWebRTC('ERROR', `Failed to restart ICE: ${error.message}`);
                            }
                        }
                        break;
                    
                    case 'audio_stream_ready':
                        logWebRTC('INFO', 'Audio stream ready from React Native');
                        // This message is handled by the waitForAudioStreamReady function
                        // when it's waiting for the audio stream to be ready
                        break;
                    
                    default:
                        logWebRTC('WARNING', `Unknown message type: ${message.type}`);
                        break;
                }
            } catch (error) {
                logWebRTC('ERROR', `Failed to handle message: ${error.message}`);
            }
        }
        
        // Listen for messages from React Native
        window.addEventListener('message', handleMessage, false);

        // Create offer
        async function createOffer() {
            console.log('[USER-APP WebView] createOffer function called - START');
            
            try {
                // Initialize peer connection if it doesn't exist
                if (!peerConnection) {
                    console.log('[USER-APP WebView] Peer connection not initialized, calling initWebRTC');
                    await initWebRTC();
                }

                if (!peerConnection) {
                    console.error('[USER-APP WebView] Failed to initialize peer connection in createOffer');
                    sendToReactNative({
                        type: 'webrtc_error',
                        data: { error: 'Failed to initialize peer connection' }
                    });
                    return;
                }

                console.log('[USER-APP WebView] Creating WebRTC offer...');
                console.log('[USER-APP WebView] Peer connection state:', peerConnection.connectionState);
                console.log('[USER-APP WebView] Peer connection signaling state:', peerConnection.signalingState);
                
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: false
                });
                
                console.log('[USER-APP WebView] Offer created successfully:', offer);
                
                await peerConnection.setLocalDescription(offer);
                console.log('[USER-APP WebView] Local description set successfully');
                
                // Send offer to React Native
                sendToReactNative({
                    type: 'voice_call_offer',
                    data: {
                        signal: {
                            type: 'offer',
                            sdp: offer.sdp,
                            to: 'astrologer'
                        }
                    }
                });
                
                console.log('[USER-APP WebView] createOffer function completed successfully - END');
                
            } catch (error) {
                console.error('[USER-APP WebView] Error in createOffer:', error);
                console.error('[USER-APP WebView] Error stack:', error.stack);
                sendToReactNative({
                    type: 'webrtc_error',
                    data: { error: error.message }
                });
            }
        }

        // Handle offer
        async function handleOffer(data) {
            try {
                logWebRTC('INFO', 'Handling voice call offer...');
                
                // Extract the offer from the data (handle both direct and nested signal structure)
                const signalData = data.signal || data;
                const offer = signalData.offer;
                if (!offer) {
                    logWebRTC('ERROR', 'Invalid offer received: ' + JSON.stringify(data));
                    return;
                }
                
                // Make sure peerConnection exists
                if (!peerConnection) {
                    logWebRTC('ERROR', 'Cannot handle offer: peerConnection is not initialized');
                    await initWebRTC(); // Try to initialize WebRTC
                    
                    if (!peerConnection) {
                        throw new Error('Failed to initialize peerConnection');
                    }
                }
                
                // Set remote description
                logWebRTC('INFO', 'Setting remote description from offer');
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                    logWebRTC('SUCCESS', 'Remote description set successfully from offer');
                } catch (sdpError) {
                    logWebRTC('ERROR', `Failed to set remote description: ${sdpError.message}`);
                    logWebRTC('DEBUG', `Problematic SDP: ${JSON.stringify(offer).substring(0, 100)}...`);
                    throw sdpError;
                }
                
                // Create and set local description (answer)
                logWebRTC('INFO', 'Creating answer');
                try {
                    const answer = await peerConnection.createAnswer();
                    logWebRTC('INFO', `Answer created: ${JSON.stringify(answer).substring(0, 50)}...`);
                    
                    logWebRTC('INFO', 'Setting local description (answer)');
                    await peerConnection.setLocalDescription(answer);
                    logWebRTC('SUCCESS', 'Local description (answer) set successfully');
                } catch (answerError) {
                    logWebRTC('ERROR', `Failed to create or set answer: ${answerError.message}`);
                    throw answerError;
                }
                
                // Send the answer to React Native
                logWebRTC('INFO', 'Sending answer to React Native');
                sendToReactNative({
                    type: 'voice_call_answer',
                    data: { answer: answer }
                });
                
                logWebRTC('SUCCESS', 'Voice call answer created and sent');
            } catch (error) {
                logWebRTC('ERROR', 'Failed to handle offer: ' + error.message);
                // Try to recover
                setTimeout(() => {
                    logWebRTC('INFO', 'Attempting to recover from offer handling failure...');
                    initWebRTC();
                }, 2000);
            }
        }

        // Handle answer
        async function handleAnswer(data) {
            try {
                logWebRTC('INFO', 'Handling answer from remote peer');
                
                // Extract the answer from the data (handle both direct and nested signal structure)
                const signalData = data.signal || data;
                // Handle both formats: {answer: {sdp, type}} and {sdp, type}
                const answer = signalData.answer || signalData;
                if (!answer || (!answer.sdp && !answer.type)) {
                    logWebRTC('ERROR', 'Invalid answer received: ' + JSON.stringify(data));
                    return;
                }
                
                // Make sure peerConnection exists
                if (!peerConnection) {
                    logWebRTC('ERROR', 'Cannot handle answer: peerConnection is not initialized');
                    await initWebRTC(); // Try to initialize WebRTC
                    
                    if (!peerConnection) {
                        logWebRTC('ERROR', 'Failed to initialize peerConnection for answer');
                        return;
                    }
                    logWebRTC('INFO', 'Initialized peerConnection for answer');
                }
                
                // Set the remote description
                logWebRTC('INFO', 'Setting remote description from answer');
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    logWebRTC('SUCCESS', 'Remote description set successfully from answer');
                    
                    // Process any pending ICE candidates now that remote description is set
                    if (window.pendingCandidates && window.pendingCandidates.length > 0) {
                        logWebRTC('INFO', `Processing ${window.pendingCandidates.length} pending ICE candidates after setting remote description`);
                        processPendingCandidates();
                    }
                    
                    // Set a timeout to check ICE connection state and potentially restart ICE if needed
                    setTimeout(() => {
                        if (peerConnection && 
                            (peerConnection.iceConnectionState === 'checking' || 
                             peerConnection.iceConnectionState === 'failed')) {
                            logWebRTC('WARNING', `ICE still in ${peerConnection.iceConnectionState} state after timeout, attempting to restart ICE`);
                            try {
                                peerConnection.restartIce();
                                logWebRTC('INFO', 'ICE restart initiated from answer handler');
                            } catch (restartError) {
                                logWebRTC('ERROR', `Failed to restart ICE from answer handler: ${restartError.message}`);
                            }
                        }
                    }, 8000); // 8 second timeout
                    
                } catch (sdpError) {
                    logWebRTC('ERROR', `Failed to set remote description from answer: ${sdpError.message}`);
                    logWebRTC('DEBUG', `Problematic SDP: ${JSON.stringify(answer).substring(0, 100)}...`);
                    throw sdpError;
                }
            } catch (error) {
                logWebRTC('ERROR', 'Failed to handle answer: ' + error.message);
            }
        }

        // Handle ICE candidate
        async function handleIceCandidate(data) {
            try {
                logWebRTC('INFO', 'Adding ICE candidate...');
                
                // Extract the candidate from the data (handle both direct and nested signal structure)
                const signalData = data.signal || data;
                const candidate = signalData.candidate;
                if (!candidate) {
                    logWebRTC('ERROR', 'Invalid ICE candidate received: ' + JSON.stringify(data));
                    return;
                }
                
                // Make sure peerConnection exists
                if (!peerConnection) {
                    logWebRTC('ERROR', 'Cannot add ICE candidate: peerConnection is not initialized');
                    await initWebRTC(); // Try to initialize WebRTC
                    
                    if (!peerConnection) {
                        logWebRTC('ERROR', 'Failed to initialize peerConnection for ICE candidate');
                        return;
                    }
                    logWebRTC('INFO', 'Initialized peerConnection for ICE candidate');
                }
                
                // Check if remote description is set (required for adding ICE candidates)
                if (!peerConnection.remoteDescription || !peerConnection.remoteDescription.type) {
                    logWebRTC('WARNING', 'Cannot add ICE candidate: Remote description not set yet');
                    
                    // Store the candidate to add later when remote description is set
                    if (!window.pendingCandidates) {
                        window.pendingCandidates = [];
                    }
                    
                    window.pendingCandidates.push(candidate);
                    logWebRTC('INFO', `Stored ICE candidate for later. Total pending: ${window.pendingCandidates.length}`);
                    return;
                }
                
                // Add the ICE candidate
                logWebRTC('INFO', 'Adding ICE candidate to peerConnection');
                try {
                    // Create a clean candidate object, filtering out null/undefined values
                    const cleanCandidate = {
                        candidate: candidate.candidate
                    };
                    
                    // Add sdpMLineIndex if it's a valid number (including 0)
                    if (candidate.sdpMLineIndex !== null && candidate.sdpMLineIndex !== undefined) {
                        cleanCandidate.sdpMLineIndex = candidate.sdpMLineIndex;
                    }
                    
                    // Add sdpMid if it's a valid string (including "0")
                    if (candidate.sdpMid !== null && candidate.sdpMid !== undefined) {
                        cleanCandidate.sdpMid = candidate.sdpMid;
                    }
                    
                    // Only add usernameFragment if it's not null/undefined
                    if (candidate.usernameFragment !== null && candidate.usernameFragment !== undefined) {
                        cleanCandidate.usernameFragment = candidate.usernameFragment;
                    }
                    
                    logWebRTC('DEBUG', `Clean candidate object: ${JSON.stringify(cleanCandidate)}`);
                    
                    await peerConnection.addIceCandidate(new RTCIceCandidate(cleanCandidate));
                    logWebRTC('SUCCESS', 'ICE candidate added successfully');
                    logWebRTC('DEBUG', `Candidate details: ${JSON.stringify(candidate).substring(0, 100)}...`);
                    
                    // Report ICE state after adding candidate
                    const iceState = peerConnection.iceConnectionState;
                    logWebRTC('INFO', `ICE state after adding candidate: ${iceState}`);
                    
                    // If we're still in checking state after a while, try restarting ICE
                    if (iceState === 'checking') {
                        setTimeout(() => {
                            if (peerConnection && peerConnection.iceConnectionState === 'checking') {
                                logWebRTC('WARNING', 'ICE still in checking state after timeout, attempting to restart ICE');
                                try {
                                    peerConnection.restartIce();
                                    logWebRTC('INFO', 'ICE restart initiated');
                                } catch (restartError) {
                                    logWebRTC('ERROR', `Failed to restart ICE: ${restartError.message}`);
                                }
                            }
                        }, 10000); // 10 second timeout
                    }
                } catch (iceError) {
                    logWebRTC('ERROR', `Failed to add ICE candidate: ${iceError.message}`);
                    logWebRTC('DEBUG', `Problematic candidate: ${JSON.stringify(candidate).substring(0, 100)}...`);
                    throw iceError;
                }
            } catch (error) {
                logWebRTC('ERROR', 'Failed to add ICE candidate: ' + error.message);
            }
        }

        // Update participant info
        function updateParticipantInfo(data) {
            const { participantName, participantType } = data;
            document.getElementById('participantInfo').textContent = 
                `${participantType === 'astrologer' ? 'Speaking with' : 'Connected to'} ${participantName}`;
        }

        // Toggle mute
        document.getElementById('toggleMic').addEventListener('click', () => {
            const audioTracks = localStream.getAudioTracks();
            audioTracks.forEach(track => {
                track.enabled = !track.enabled;
            });
            
            isMuted = !isMuted;
            const button = document.getElementById('toggleMic');
            
            if (isMuted) {
                button.classList.add('muted');
                button.textContent = '🔇';
                button.title = 'Unmute Microphone';
            } else {
                button.classList.remove('muted');
                button.textContent = '🎤';
                button.title = 'Mute Microphone';
            }
            
            sendToReactNative({
                type: 'audio_toggle',
                data: { muted: isMuted }
            });
            
            logWebRTC('INFO', isMuted ? 'Microphone muted' : 'Microphone unmuted');
        });

        // End call
        function endCall() {
            logWebRTC('INFO', 'Ending voice call...');
            
            // Clear timer
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
            
            // Close audio context
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            // Close peer connection
            if (peerConnection) {
                peerConnection.close();
            }
            
            sendToReactNative({
                type: 'call_ended',
                data: { reason: 'user_ended' }
            });
            
            logWebRTC('SUCCESS', 'Voice call ended');
        }

        // End call button
        document.getElementById('endCall').addEventListener('click', endCall);
        
        // Notify React Native that WebRTC connection is established
        function notifyWebRTCConnectionEstablished() {
            logWebRTC('INFO', 'Local WebRTC connection established, notifying React Native');
            
            // Only notify once
            if (!hasNotifiedConnectionEstablished) {
                hasNotifiedConnectionEstablished = true;
                
                sendToReactNative({
                    type: 'webrtc_local_connection_established',
                    data: { success: true }
                });
                
                logWebRTC('SUCCESS', 'Notified React Native of established WebRTC connection');
            }
        }
        
        // Initialize WebRTC when page loads
        document.addEventListener('DOMContentLoaded', function() {
            logWebRTC('INFO', 'DOM content loaded, initializing WebRTC');
            setTimeout(() => {
                initWebRTC();
                sendToReactNative({
                    type: 'webrtc_ready',
                    data: { ready: true }
                });
            }, 500); // Small delay to ensure everything is ready
        });
        
        // Backup initialization in case DOMContentLoaded already fired
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            logWebRTC('INFO', 'Document already loaded, initializing WebRTC...');
            setTimeout(() => {
                initWebRTC();
            }, 500);
        }

        // Format time as MM:SS
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Start timer (now only called explicitly)
        function explicitStartTimer() {
            // Don't start if already running
            if (callTimer) {
                console.log('Timer already running, not starting again');
                return;
            }
            
            logWebRTC('INFO', 'Explicitly starting consultation timer');
            startTime = Date.now();
            callTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('timerDisplay').textContent = formatTime(elapsed);
                
                // Send timer update to React Native
                sendToReactNative({
                    type: 'timer_update',
                    data: { duration: elapsed }
                });
            }, 1000);
            
            // Update UI to show active call
            document.getElementById('connectionStatus').innerHTML = 
                '<span class="status-connected">● Connected</span>';
            document.getElementById('callStatus').textContent = 'Voice Call in Progress';
        }

        // Simplified reinitialize function for compatibility
        async function reinitializeWebRTC(data) {
            logWebRTC('INFO', 'Reinitialize WebRTC called - using direct getUserMedia approach');
            
            // With the simplified approach, we don't need to reinitialize
            sendToReactNative({
                type: 'webrtc_reinitialized',
                data: {
                    success: true,
                    usingRealAudio: true,
                    info: 'Using direct getUserMedia',
                    details: 'Audio is handled through direct getUserMedia, no reinitialization needed.'
                }
            });
        }

        // Add pending candidates array for ICE candidate buffering
        window.pendingCandidates = [];

        // Process pending ICE candidates after remote description is set
        function processPendingCandidates() {
            if (!window.pendingCandidates || window.pendingCandidates.length === 0) {
                logWebRTC('INFO', 'No pending ICE candidates to process');
                return;
            }

            logWebRTC('INFO', `Processing ${window.pendingCandidates.length} pending ICE candidates`);
            
            window.pendingCandidates.forEach(async (candidateData, index) => {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidateData));
                    logWebRTC('SUCCESS', `Successfully added pending ICE candidate ${index + 1}`);
                } catch (error) {
                    logWebRTC('ERROR', `Failed to add pending ICE candidate ${index + 1}: ${error.message}`);
                }
            });
            
            // Clear the pending candidates array
            window.pendingCandidates = [];
            logWebRTC('INFO', 'Cleared pending ICE candidates array');
        }

        // Helper function to wait for audio stream ready from React Native
        function waitForAudioStreamReady() {
            return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                    logWebRTC('WARNING', 'Timeout waiting for audio stream from React Native');
                    resolve(false);
                }, 5000); // 5 second timeout

                const handleAudioStreamReady = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        if (message.type === 'audio_stream_ready') {
                            clearTimeout(timeout);
                            logWebRTC('INFO', 'Audio stream ready from React Native');
                            window.removeEventListener('message', handleAudioStreamReady);
                            resolve(true);
                        }
                    } catch (error) {
                        // Ignore parsing errors for non-JSON messages
                    }
                };

                window.addEventListener('message', handleAudioStreamReady);
            });
        }

        // Helper function to create placeholder audio stream for WebRTC
        function createPlaceholderAudioStream() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const destination = audioContext.createMediaStreamDestination();
                
                // Create a very quiet low-frequency tone (20Hz, 0.01 gain)
                oscillator.frequency.setValueAtTime(20, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.01, audioContext.currentTime);
                
                oscillator.connect(gainNode);
                gainNode.connect(destination);
                oscillator.start();
                
                logWebRTC('INFO', 'Created placeholder audio stream (20Hz, 0.01 gain)');
                return destination.stream;
            } catch (error) {
                logWebRTC('ERROR', `Failed to create placeholder audio stream: ${error.message}`);
                throw error;
            }
        }
    </script>
</body>
</html>
